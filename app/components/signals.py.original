import streamlit as st
import pandas as pd
import numpy as np
import pytz
from datetime import datetime, time
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from typing import Dict
import plotly.express as px
import traceback
import matplotlib.pyplot as plt

from app.signals import generate_signals, SignalStrength
from app.signals.generator import create_default_signal_generator, generate_signals_advanced, analyze_exit_strategy
from app.signals.timeframes import TimeFrame, TimeFramePriority
from app.indicators import calculate_opening_range

def is_market_hours(timestamp):
    """
    Check if the given timestamp is during market hours (9:30 AM - 4:00 PM ET, Monday-Friday)
    
    Args:
        timestamp: Datetime object or index
        
    Returns:
        bool: True if timestamp is during market hours, False otherwise
    """
    # If timestamp has no tzinfo, assume it's UTC and convert to Eastern
    if hasattr(timestamp, 'tzinfo'):
        if timestamp.tzinfo is None:
            timestamp = timestamp.replace(tzinfo=pytz.UTC)
        # Convert to Eastern Time
        eastern = pytz.timezone('US/Eastern')
        timestamp = timestamp.astimezone(eastern)
    else:
        # If not a datetime, just return True (can't determine)
        return True
    
    # Check if it's a weekday (0 = Monday, 4 = Friday)
    if timestamp.weekday() > 4:  # Saturday or Sunday
        return False
    
    # Check if during market hours (9:30 AM - 4:00 PM ET)
    market_open = time(9, 30)
    market_close = time(16, 0)
    current_time = timestamp.time()
    
    return market_open <= current_time <= market_close

def format_timestamp_as_et(timestamp):
    """
    Format timestamp in Eastern Time with appropriate market hours indication
    
    Args:
        timestamp: Datetime object or index
        
    Returns:
        str: Formatted timestamp string in Eastern Time
    """
    # Handle None value
    if timestamp is None:
        return "N/A"
        
    if not hasattr(timestamp, 'tzinfo'):
        return str(timestamp)
    
    # Convert to Eastern Time
    if timestamp.tzinfo is None:
        timestamp = timestamp.replace(tzinfo=pytz.UTC)
    eastern = pytz.timezone('US/Eastern')
    et_time = timestamp.astimezone(eastern)
    
    # Format as string with ET indicator
    formatted = et_time.strftime('%Y-%m-%d %H:%M ET')
    
    # Add market status
    if is_market_hours(timestamp):
        return f"{formatted} (Market Open)"
    else:
        return f"{formatted} (Market Closed)"

def render_signal_table(data):
    """
    Render a table of trading signals with explanations
    
    Args:
        data (pd.DataFrame): DataFrame with price data
    """
    # Check if signals exist in session state first
    if 'signals' not in st.session_state or st.session_state.signals is None:
        # If not in session state, generate them
        from app.signals import generate_signals
        
        st.header("Trading Signals")
        
        # Generate signals from data
        with st.spinner("Generating signals..."):
            signals = generate_signals(data)
    else:
        # Use existing signals from session state
        signals = st.session_state.signals
        st.header("Trading Signals")
        
    # Check if we have advanced results available
    has_advanced = hasattr(st.session_state, 'advanced_results') and st.session_state.advanced_results is not None
    advanced_results = getattr(st.session_state, 'advanced_results', None) if has_advanced else None
    
    # Ensure signal prices match actual data prices for display
    if 'signal_price' in signals.columns:
        signal_indices = signals.index
        for idx in signal_indices:
            if idx in data.index and 'close' in data.columns:
                # Update signal price to match actual close price
                signals.loc[idx, 'signal_price'] = data.loc[idx, 'close']
    
    # Display basic information about signals
    buy_signals_count = signals['buy_signal'].astype(bool).sum() if 'buy_signal' in signals.columns else 0
    sell_signals_count = signals['sell_signal'].astype(bool).sum() if 'sell_signal' in signals.columns else 0
    total_signals = buy_signals_count + sell_signals_count
    
    if has_advanced:
        regime = advanced_results.get('market_regime', 'unknown').replace('_', ' ').title()
        st.info(f"Found {total_signals} signals ({buy_signals_count} buy, {sell_signals_count} sell) - Market Regime: {regime}")
    else:
        st.info(f"Found {total_signals} signals ({buy_signals_count} buy, {sell_signals_count} sell)")
    
    # Import exit strategy analyzer
    from app.signals.generator import analyze_exit_strategy
    
    # Get signals with actual buy or sell signals
    if 'buy_signal' in signals.columns and 'sell_signal' in signals.columns:
        buy_mask = signals['buy_signal'].astype(bool)
        sell_mask = signals['sell_signal'].astype(bool)
        valid_signals = signals[buy_mask | sell_mask]
    else:
        valid_signals = pd.DataFrame(index=signals.index)
    
    # If no valid signals were found after filtering, get more recent data
    if valid_signals.empty:
        recent_signals = signals.tail(10).copy()
    else:
        # Get the most recent signals (up to 20, with at least 5 signals if available)
        signal_count = min(max(5, valid_signals.shape[0]), 20)
        recent_signals = valid_signals.tail(signal_count).copy()
    
    # Display the signal table
    if recent_signals.empty:
        st.info("No signals generated for this data")
        return
        
    # Create a formatted table
    signal_data = []
    
    # Track exit signals for entry signals to display them together
    entry_exit_pairs = []
    
    for idx, row in recent_signals.iterrows():
        try:
            # Format date/time in Eastern Time
            if hasattr(idx, 'tzinfo'):
                try:
                    # Convert to Eastern time if it's timezone-aware
                    eastern = pytz.timezone('US/Eastern')
                    date = idx.astimezone(eastern).strftime('%Y-%m-%d %H:%M:%S ET')
                except:
                    date = str(idx)
            else:
                date = str(idx)
            
            # Determine signal type and explanation
            signal_type = ""
            explanation = ""
            target = ""
            stop_loss = ""
            strategy = ""
            exit_recommendation = ""
            exit_reason = ""
            exit_time = None
            exit_price = None
            
            if row['buy_signal']:
                signal_type = "Buy"
                price = data.loc[idx, 'close'] if idx in data.index else row.get('signal_price', 0)
                
                # Calculate exit recommendation for this buy signal
                buy_position = {
                    'type': 'long',
                    'entry_price': price,
                    'entry_time': idx
                }
                
                exit_analysis = analyze_exit_strategy(data, buy_position)
                if exit_analysis['success']:
                    action = exit_analysis['action']
                    if action['close_percent'] == 0:
                        exit_recommendation = "Hold"
                    elif action['close_percent'] == 100:
                        exit_recommendation = "Close 100%"
                    else:
                        exit_recommendation = f"Close {action['close_percent']}%"
                    
                    exit_reason = action['reason'].replace('_', ' ').title()
                    
                    # Try to find a reasonable exit time based on exit reason
                    reason = action['reason']
                    later_data = data.loc[data.index > idx]
                    
                    if not later_data.empty:
                        if reason == 'atr_stop':
                            # For ATR stops, find where price crosses the stop level
                            atr_stop = exit_analysis['atr_stop']
                            if atr_stop is not None:
                                for exit_idx, exit_row in later_data.iterrows():
                                    if exit_row['low'] <= atr_stop:
                                        exit_time = exit_idx
                                        exit_price = atr_stop
                        elif reason == 'time_exit':
                            # For time exits, use position age to determine exit
                            exit_time_threshold = idx + pd.Timedelta(minutes=45)
                            exit_times = later_data.index[later_data.index >= exit_time_threshold]
                            if len(exit_times) > 0:
                                exit_time = exit_times[0]
                                exit_price = later_data.loc[exit_time, 'close']
                        elif reason == 'end_of_day':
                            # For end of day, use 3:45-4:00 PM ET
                            for exit_idx, _ in later_data.iterrows():
                                if exit_idx.hour == 15 and exit_idx.minute >= 45:
                                    exit_time = exit_idx
                                    exit_price = later_data.loc[exit_time, 'close']
                                    break
                        else:
                            # For other reasons, use last available point
                            exit_time = later_data.index[-1]
                            exit_price = later_data.loc[exit_time, 'close']
                
                # If no exit time was determined, use the last available data point
                if exit_time is None and len(later_data) > 0:
                    exit_time = later_data.index[-1]
                    exit_price = later_data.loc[exit_time, 'close']
                
                # Safely check for strategy indicators
                is_ema_vwap_bullish = row.get('ema_vwap_bullish', False) 
                is_mm_vol_bullish = row.get('mm_vol_bullish', False)
                is_price_cross_above_ema20 = row.get('price_cross_above_ema20', False)
                is_price_above_ema50 = row.get('price_above_ema50', False)
                is_macd_cross_above_signal = row.get('macd_cross_above_signal', False)
                is_ema_cloud_cross_bullish = row.get('ema_cloud_cross_bullish', False)
                is_stochastic_k_cross_above_d = row.get('stochastic_k_cross_above_d', False)
                is_stochastic_oversold = row.get('stochastic_oversold', False)
                
                # Determine if the signal is from a strategic combination
                if is_ema_vwap_bullish:
                    strategy = "EMA Cloud + VWAP"
                    explanation = "Price bounced off EMA cloud while above VWAP"
                elif is_mm_vol_bullish:
                    strategy = "Measured Move + Volume"
                    explanation = "Completed measured move pattern with strong volume"
                # Original signals logic
                elif is_price_cross_above_ema20 and is_price_above_ema50:
                    explanation = "Price crossed above EMA20 while above EMA50"
                elif is_macd_cross_above_signal:
                    explanation = "MACD crossed above signal line"
                elif is_ema_cloud_cross_bullish:
                    explanation = "EMA cloud turned bullish"
                elif is_stochastic_k_cross_above_d and is_stochastic_oversold:
                    explanation = "Stochastic K line crossed above D while oversold"
                else:
                    explanation = "Multiple indicators turned bullish"
                
                # Check if this is the latest signal and we have advanced results
                if has_advanced and idx == data.index[-1] and 'final_signal' in advanced_results:
                    final_signal = advanced_results['final_signal']
                    if final_signal.get('buy_signal', False):
                        explanation = "Advanced multi-timeframe analysis confirms bullish signal"
                        strategy = "Multi-Timeframe"
                
                # Add target price and stop loss if available
                target_price = row.get('target_price', np.nan)
                stop_loss_price = row.get('stop_loss', np.nan)
                
                if not pd.isna(target_price) and target_price is not None:
                    target = f"${target_price:.2f} ({((target_price / price) - 1) * 100:.1f}%)"
                
                if not pd.isna(stop_loss_price) and stop_loss_price is not None:
                    stop_loss = f"${stop_loss_price:.2f} ({((stop_loss_price / price) - 1) * 100:.1f}%)"
                
                # Use ATR stop from exit analysis if available
                if exit_analysis['success'] and exit_analysis['atr_stop'] is not None:
                    atr_stop = exit_analysis['atr_stop']
                    if not pd.isna(atr_stop):
                        stop_loss = f"${atr_stop:.2f} ({((atr_stop / price) - 1) * 100:.1f}%)"
                
                if exit_time is not None:
                    # Format exit timestamp in Eastern Time
                    if hasattr(exit_time, 'tzinfo'):
                        try:
                            eastern = pytz.timezone('US/Eastern')
                            exit_time_str = exit_time.astimezone(eastern).strftime('%Y-%m-%d %H:%M:%S ET')
                        except:
                            exit_time_str = str(exit_time)
                    else:
                        exit_time_str = str(exit_time)
                    
                    # Calculate P&L
                    if exit_price is not None and price > 0:
                        profit_pct = ((exit_price / price) - 1) * 100
                    else:
                        profit_pct = 0
                        
                    # Store the entry-exit pair for later use
                    entry_exit_pairs.append({
                        'entry_type': 'BUY',
                        'entry_time': idx,
                        'entry_time_str': date,
                        'entry_price': price,
                        'exit_time': exit_time,
                        'exit_time_str': exit_time_str,
                        'exit_price': exit_price,
                        'exit_price_str': f"${exit_price:.2f}" if exit_price is not None else "N/A",
                        'exit_reason': exit_reason,
                        'profit_pct': profit_pct,
                        'profit_str': f"{profit_pct:.2f}%",
                        'exit_recommendation': exit_recommendation
                    })
                    
            elif row['sell_signal']:
                signal_type = "Sell"
                price = data.loc[idx, 'close'] if idx in data.index else row.get('signal_price', 0)
                
                # Calculate exit recommendation for this sell signal
                sell_position = {
                    'type': 'short',
                    'entry_price': price,
                    'entry_time': idx
                }
                
                exit_analysis = analyze_exit_strategy(data, sell_position)
                if exit_analysis['success']:
                    action = exit_analysis['action']
                    if action['close_percent'] == 0:
                        exit_recommendation = "Hold"
                    elif action['close_percent'] == 100:
                        exit_recommendation = "Close 100%"
                    else:
                        exit_recommendation = f"Close {action['close_percent']}%"
                    
                    exit_reason = action['reason'].replace('_', ' ').title()
                    
                    # Try to find a reasonable exit time based on exit reason
                    reason = action['reason']
                    later_data = data.loc[data.index > idx]
                    
                    if not later_data.empty:
                        if reason == 'atr_stop':
                            # For ATR stops, find where price crosses the stop level
                            atr_stop = exit_analysis['atr_stop']
                            if atr_stop is not None:
                                for exit_idx, exit_row in later_data.iterrows():
                                    if exit_row['high'] >= atr_stop:
                                        exit_time = exit_idx
                                        exit_price = atr_stop
                        elif reason == 'time_exit':
                            # For time exits, use position age to determine exit
                            exit_time_threshold = idx + pd.Timedelta(minutes=45)
                            exit_times = later_data.index[later_data.index >= exit_time_threshold]
                            if len(exit_times) > 0:
                                exit_time = exit_times[0]
                                exit_price = later_data.loc[exit_time, 'close']
                        elif reason == 'end_of_day':
                            # For end of day, use 3:45-4:00 PM ET
                            for exit_idx, _ in later_data.iterrows():
                                if exit_idx.hour == 15 and exit_idx.minute >= 45:
                                    exit_time = exit_idx
                                    exit_price = later_data.loc[exit_time, 'close']
                                    break
                        else:
                            # For other reasons, use last available point
                            exit_time = later_data.index[-1]
                            exit_price = later_data.loc[exit_time, 'close']
                
                # If no exit time was determined, use the last available data point
                if exit_time is None and len(later_data) > 0:
                    exit_time = later_data.index[-1]
                    exit_price = later_data.loc[exit_time, 'close']
                
                # Safely check for strategy indicators
                is_ema_vwap_bearish = row.get('ema_vwap_bearish', False)
                is_mm_vol_bearish = row.get('mm_vol_bearish', False)
                is_price_cross_below_ema20 = row.get('price_cross_below_ema20', False)
                is_price_above_ema50 = row.get('price_above_ema50', False)
                is_macd_cross_below_signal = row.get('macd_cross_below_signal', False)
                is_ema_cloud_cross_bearish = row.get('ema_cloud_cross_bearish', False)
                is_stochastic_k_cross_below_d = row.get('stochastic_k_cross_below_d', False)
                is_stochastic_overbought = row.get('stochastic_overbought', False)
                
                # Determine if the signal is from a strategic combination
                if is_ema_vwap_bearish:
                    strategy = "EMA Cloud + VWAP"
                    explanation = "Price bounced down from EMA cloud while below VWAP"
                elif is_mm_vol_bearish:
                    strategy = "Measured Move + Volume"
                    explanation = "Completed measured move pattern with strong volume"
                # Original signals logic
                elif is_price_cross_below_ema20 and not is_price_above_ema50:
                    explanation = "Price crossed below EMA20 while below EMA50"
                elif is_macd_cross_below_signal:
                    explanation = "MACD crossed below signal line"
                elif is_ema_cloud_cross_bearish:
                    explanation = "EMA cloud turned bearish"
                elif is_stochastic_k_cross_below_d and is_stochastic_overbought:
                    explanation = "Stochastic K line crossed below D while overbought"
                else:
                    explanation = "Multiple indicators turned bearish"
                
                # Check if this is the latest signal and we have advanced results
                if has_advanced and idx == data.index[-1] and 'final_signal' in advanced_results:
                    final_signal = advanced_results['final_signal']
                    if final_signal.get('sell_signal', False):
                        explanation = "Advanced multi-timeframe analysis confirms bearish signal"
                        strategy = "Multi-Timeframe"
                
                # Add target price and stop loss if available
                target_price = row.get('target_price', np.nan)
                stop_loss_price = row.get('stop_loss', np.nan)
                
                if not pd.isna(target_price) and target_price is not None:
                    target = f"${target_price:.2f} ({((target_price / price) - 1) * 100:.1f}%)"
                
                if not pd.isna(stop_loss_price) and stop_loss_price is not None:
                    stop_loss = f"${stop_loss_price:.2f} ({((stop_loss_price / price) - 1) * 100:.1f}%)"
            
                # Use ATR stop from exit analysis if available
                if exit_analysis['success'] and exit_analysis['atr_stop'] is not None:
                    atr_stop = exit_analysis['atr_stop']
                    if not pd.isna(atr_stop):
                        stop_loss = f"${atr_stop:.2f} ({((atr_stop / price) - 1) * 100:.1f}%)"
                
                if exit_time is not None:
                    # Format exit timestamp in Eastern Time
                    if hasattr(exit_time, 'tzinfo'):
                        try:
                            eastern = pytz.timezone('US/Eastern')
                            exit_time_str = exit_time.astimezone(eastern).strftime('%Y-%m-%d %H:%M:%S ET')
                        except:
                            exit_time_str = str(exit_time)
                    else:
                        exit_time_str = str(exit_time)
                    
                    # Calculate P&L for short position
                    if exit_price is not None and price > 0:
                        profit_pct = ((price / exit_price) - 1) * 100
                    else:
                        profit_pct = 0
                        
                    # Store the entry-exit pair for later use
                    entry_exit_pairs.append({
                        'entry_type': 'SELL',
                        'entry_time': idx,
                        'entry_time_str': date,
                        'entry_price': price,
                        'exit_time': exit_time,
                        'exit_time_str': exit_time_str,
                        'exit_price': exit_price,
                        'exit_price_str': f"${exit_price:.2f}" if exit_price is not None else "N/A",
                        'exit_reason': exit_reason,
                        'profit_pct': profit_pct,
                        'profit_str': f"{profit_pct:.2f}%",
                        'exit_recommendation': exit_recommendation
                    })
                    
            # Add price with formatting
            if idx in data.index and 'close' in data.columns:
                price = data.loc[idx, 'close']
                formatted_price = f"${price:.2f}"
            elif 'signal_price' in row and row['signal_price'] is not None:
                price = row['signal_price']
                formatted_price = f"${price:.2f}"
            else:
                formatted_price = "N/A"
            
            # Add signal strength if available
            strength = ""
            if signal_type == "Buy" and "buy_strength" in row:
                strength = str(row["buy_strength"])
            elif signal_type == "Sell" and "sell_strength" in row:
                strength = str(row["sell_strength"])
                
            # Add to signal data table
            signal_data.append({
                "Time": date,
                "Signal": signal_type,
                "Price": formatted_price,
                "Strength": strength,
                "Explanation": explanation,
                "Target": target,
                "Stop Loss": stop_loss,
            })
            
        except Exception as e:
            print(f"Error processing signal: {str(e)}")
            traceback.print_exc()
            
    # Add entry-exit pairs to the signal data if any exist
    for pair in entry_exit_pairs:
        try:
            signal_data.append({
                "Time": pair['exit_time_str'],
                "Signal": f"EXIT {pair['entry_type']}",
                "Price": pair['exit_price_str'],
                "Strength": pair['exit_recommendation'],
                "Explanation": f"Exit reason: {pair['exit_reason']}",
                "Target": "N/A",
                "Stop Loss": "N/A",
                "P&L": pair['profit_str']
            })
        except Exception as e:
            print(f"Error adding exit signal: {str(e)}")
    
    # Sort signal data by time (newest first)
    signal_data.sort(key=lambda x: x["Time"], reverse=True)
    
    # Create the dataframe for display
    signal_df = pd.DataFrame(signal_data)
    
    # Apply styling to highlight different signal types
    def color_signals(val):
        if val == "Buy":
            return 'background-color: rgba(0, 255, 0, 0.2)'
        elif val == "Sell":
            return 'background-color: rgba(255, 0, 0, 0.2)'
        elif "EXIT" in str(val):
            return 'background-color: rgba(100, 100, 255, 0.3)'
        return ''
    
    # Display the signal table with styling
    if 'P&L' in signal_df.columns:
        # Apply conditional formatting to P&L column
        def color_pl(val):
            if not isinstance(val, str):
                return ''
            if "%" not in val:
                return ''
            try:
                value = float(val.replace('%', ''))
                if value > 0:
                    return 'color: green'
                elif value < 0:
                    return 'color: red'
            except:
                pass
            return ''
        
        st.dataframe(
            signal_df.style.applymap(color_signals, subset=['Signal'])
                         .applymap(color_pl, subset=['P&L']),
            use_container_width=True
        )
    else:
        st.dataframe(
            signal_df.style.applymap(color_signals, subset=['Signal']),
            use_container_width=True
        )

    # Add exit signal information specifically for new exit strategy
    st.subheader("Exit Signal Analysis")
    
    # Process through both buy and sell exit signals
    exit_signals = []
    
    # Check for exit_buy signals
    if 'exit_buy' in signal_data.columns:
        exit_buy_signals = signal_data[signal_data['exit_buy'] == True]
        for idx, row in exit_buy_signals.iterrows():
            exit_signals.append({
                "Time": format_timestamp_as_et(idx),
                "Type": "Exit Long",
                "Price": f"${data.loc[idx, 'close']:.2f}" if idx in data.index else "N/A",
                "Reason": "Momentum/RSI Weakening" if 'exit_reason' not in row else row['exit_reason']
            })
    
    # Check for exit_sell signals
    if 'exit_sell' in signal_data.columns:
        exit_sell_signals = signal_data[signal_data['exit_sell'] == True]
        for idx, row in exit_sell_signals.iterrows():
            exit_signals.append({
                "Time": format_timestamp_as_et(idx),
                "Type": "Exit Short",
                "Price": f"${data.loc[idx, 'close']:.2f}" if idx in data.index else "N/A",
                "Reason": "Momentum/RSI Strengthening" if 'exit_reason' not in row else row['exit_reason']
            })
    
    # Sort by time
    exit_signals.sort(key=lambda x: x["Time"])
    
    # Display the exit signals if any are found
    if exit_signals:
        exit_df = pd.DataFrame(exit_signals)
        
        # Apply styling
        def color_exit_type(val):
            if val == "Exit Long":
                return "background-color: #d4eaff; color: #0366d6"
            elif val == "Exit Short":
                return "background-color: #ffebd4; color: #d66f03"
            return ""
        
        st.dataframe(
            exit_df.style.applymap(color_exit_type, subset=['Type']),
            use_container_width=True
        )
    else:
        st.info("No exit signals generated for this data range")

def render_signals(data, signal_data=None, symbol=None):
    """
    Render signal data with visualization and detailed information
    
    Args:
        data: DataFrame with price data
        signal_data: Optional pre-calculated signal data (if None, will be calculated)
        symbol: Trading symbol being analyzed (optional)
    """
    from app.signals.generator import analyze_exit_strategy
    
    st.header("Signal Analysis")
    
    if symbol:
        st.subheader(f"Symbol: {symbol}")
    
    if signal_data is None:
        if data is not None:
            signal_data = generate_signals(data)
        else:
            st.warning("No data available for signal generation")
            return
    
    # Check if we have signals
    if signal_data is None or not isinstance(signal_data, pd.DataFrame) or len(signal_data) == 0:
        st.warning("No signals generated")
        return
        
    # Process all entry/exit pairs for display
    entry_exit_pairs = []
    
    # Get buy and sell signals
    buy_signals = signal_data[signal_data['buy_signal']] if 'buy_signal' in signal_data.columns else pd.DataFrame()
    sell_signals = signal_data[signal_data['sell_signal']] if 'sell_signal' in signal_data.columns else pd.DataFrame()
    
    # Process buy signals to find exit points
    for idx, row in buy_signals.iterrows():
        try:
            # Create position object
            entry_price = data.loc[idx, 'close'] if idx in data.index else row.get('signal_price', 0)
            position = {
                'type': 'long',
                'entry_price': entry_price,
                'entry_time': idx
            }
            
            # Find exit using exit strategy
            exit_analysis = analyze_exit_strategy(data, position)
            
            if exit_analysis['success'] and exit_analysis['action']['close_percent'] > 0:
                # Calculate exit time based on conditions
                current_time = idx
                exit_time = None
                exit_price = None
                
                # Find the appropriate exit time based on the exit reason
                reason = exit_analysis['action']['reason']
                
                # Simulate finding an actual exit timestamp after the entry
                later_data = data.loc[data.index > idx]
                
                if not later_data.empty:
                    if reason == 'atr_stop':
                        # Find when price hit the ATR stop level
                        atr_stop = exit_analysis['atr_stop']
                        if position['type'] == 'long':
                            # For long, find when price fell below ATR stop
                            stop_hits = later_data[later_data['low'] <= atr_stop]
                            if not stop_hits.empty:
                                exit_time = stop_hits.index[0]
                                exit_price = atr_stop
                    
                    elif reason == 'time_exit':
                        # Calculate time exit point (e.g., 45 min after entry)
                        if isinstance(idx, pd.Timestamp):
                            target_time = idx + pd.Timedelta(minutes=45)
                            # Find closest data point
                            closest_idx = later_data.index[later_data.index >= target_time]
                            if len(closest_idx) > 0:
                                exit_time = closest_idx[0]
                                exit_price = later_data.loc[exit_time, 'close']
                    
                    elif reason == 'profit_target':
                        # Find when price reached target profit level
                        profit_target = entry_price * 1.02  # Example 2% profit
                        target_hits = later_data[later_data['high'] >= profit_target]
                        if not target_hits.empty:
                            exit_time = target_hits.index[0]
                            exit_price = profit_target
                    
                    elif reason == 'momentum_exit':
                        # Use last available point if no specific exit found
                        # In real implementation, we'd look for RSI > 65 and MACD < 0
                        exit_time = later_data.index[-1]
                        exit_price = later_data.loc[exit_time, 'close']
                    
                    else:
                        # Default to last available point
                        exit_time = later_data.index[-1]
                        exit_price = later_data.loc[exit_time, 'close']
                
                # If exit time wasn't found, use the last available data point
                if exit_time is None and len(data.index) > 0:
                    exit_time = data.index[-1]
                    exit_price = data.loc[exit_time, 'close']
                
                # Calculate profit/loss
                if exit_price is not None and entry_price > 0:
                    profit_pct = ((exit_price / entry_price) - 1) * 100
                else:
                    profit_pct = 0
                
                # Add entry-exit pair to our list
                entry_exit_pairs.append({
                    'entry_type': 'BUY',
                    'entry_time': idx,
                    'entry_price': entry_price,
                    'exit_time': exit_time,
                    'exit_price': exit_price,
                    'exit_reason': reason.replace('_', ' ').title(),
                    'exit_percent': exit_analysis['action']['close_percent'],
                    'profit_pct': profit_pct,
                    'color': 'green' if profit_pct > 0 else 'red',
                    'position_type': 'long'
                })
        except Exception as e:
            print(f"Error processing buy signal at {idx}: {str(e)}")
    
    # Process sell signals to find exit points
    for idx, row in sell_signals.iterrows():
        try:
            # Create position object
            entry_price = data.loc[idx, 'close'] if idx in data.index else row.get('signal_price', 0)
            position = {
                'type': 'short',
                'entry_price': entry_price,
                'entry_time': idx
            }
            
            # Find exit using exit strategy
            exit_analysis = analyze_exit_strategy(data, position)
            
            if exit_analysis['success'] and exit_analysis['action']['close_percent'] > 0:
                # Calculate exit time based on conditions
                current_time = idx
                exit_time = None
                exit_price = None
                
                # Find the appropriate exit time based on the exit reason
                reason = exit_analysis['action']['reason']
                
                # Simulate finding an actual exit timestamp after the entry
                later_data = data.loc[data.index > idx]
                
                if not later_data.empty:
                    if reason == 'atr_stop':
                        # Find when price hit the ATR stop level
                        atr_stop = exit_analysis['atr_stop']
                        if position['type'] == 'short':
                            # For short, find when price rose above ATR stop
                            stop_hits = later_data[later_data['high'] >= atr_stop]
                            if not stop_hits.empty:
                                exit_time = stop_hits.index[0]
                                exit_price = atr_stop
                    
                    elif reason == 'time_exit':
                        # Calculate time exit point (e.g., 45 min after entry)
                        if isinstance(idx, pd.Timestamp):
                            target_time = idx + pd.Timedelta(minutes=45)
                            # Find closest data point
                            closest_idx = later_data.index[later_data.index >= target_time]
                            if len(closest_idx) > 0:
                                exit_time = closest_idx[0]
                                exit_price = later_data.loc[exit_time, 'close']
                    
                    elif reason == 'profit_target':
                        # Find when price reached target profit level
                        profit_target = entry_price * 0.98  # Example 2% drop for short
                        target_hits = later_data[later_data['low'] <= profit_target]
                        if not target_hits.empty:
                            exit_time = target_hits.index[0]
                            exit_price = profit_target
                    
                    elif reason == 'momentum_exit':
                        # Use last available point if no specific exit found
                        exit_time = later_data.index[-1]
                        exit_price = later_data.loc[exit_time, 'close']
                    
                    else:
                        # Default to last available point
                        exit_time = later_data.index[-1]
                        exit_price = later_data.loc[exit_time, 'close']
                
                # If exit time wasn't found, use the last available data point
                if exit_time is None and len(data.index) > 0:
                    exit_time = data.index[-1]
                    exit_price = data.loc[exit_time, 'close']
                
                # Calculate profit/loss
                if exit_price is not None and entry_price > 0:
                    profit_pct = ((entry_price / exit_price) - 1) * 100
                else:
                    profit_pct = 0
                
                # Add entry-exit pair to our list
                entry_exit_pairs.append({
                    'entry_type': 'SELL',
                    'entry_time': idx,
                    'entry_price': entry_price,
                    'exit_time': exit_time,
                    'exit_price': exit_price,
                    'exit_reason': reason.replace('_', ' ').title(),
                    'exit_percent': exit_analysis['action']['close_percent'],
                    'profit_pct': profit_pct,
                    'color': 'green' if profit_pct > 0 else 'red',
                    'position_type': 'short'
                })
        except Exception as e:
            print(f"Error processing sell signal at {idx}: {str(e)}")
    
    # Create a price chart with signals marked
    st.subheader("Price Chart with Entry/Exit Signals")
    
    try:
        # Create candlestick chart with signal points
        fig = go.Figure()
        
        # Add candlestick trace
        fig.add_trace(
            go.Candlestick(
            x=data.index,
            open=data['open'],
            high=data['high'],
            low=data['low'],
            close=data['close'],
                name='Price'
            )
        )
        
        # Add signals as scatter points
        # Raw Buy Signals
        buy_signals = signal_data[signal_data['buy_signal']]
        if not buy_signals.empty:
            fig.add_trace(
                go.Scatter(
                    x=buy_signals.index,
                    y=data.loc[buy_signals.index, 'low'] * 0.999,  # Slightly below low for visibility
                    mode='markers',
                    marker=dict(symbol='triangle-up', size=10, color='rgba(0, 255, 0, 0.5)'),
                    name='Raw Buy Signals'
                )
            )
        
        # Raw Sell Signals
        sell_signals = signal_data[signal_data['sell_signal']]
        if not sell_signals.empty:
            fig.add_trace(
                go.Scatter(
                    x=sell_signals.index,
                    y=data.loc[sell_signals.index, 'high'] * 1.001,  # Slightly above high for visibility
                    mode='markers',
                    marker=dict(symbol='triangle-down', size=10, color='rgba(255, 0, 0, 0.5)'),
                    name='Raw Sell Signals'
                )
            )
        
        # Filtered Buy Signals
        if 'filtered_buy_signal' in signal_data.columns:
            filtered_buys = signal_data[signal_data['filtered_buy_signal']]
            if not filtered_buys.empty:
                fig.add_trace(
                    go.Scatter(
                        x=filtered_buys.index,
                        y=data.loc[filtered_buys.index, 'low'] * 0.998,  # Below raw signals
                        mode='markers',
                        marker=dict(symbol='triangle-up', size=14, color='green', line=dict(width=2, color='black')),
                        name='Filtered Buy Signals'
                    )
                )
                
        # Filtered Sell Signals
        if 'filtered_sell_signal' in signal_data.columns:
            filtered_sells = signal_data[signal_data['filtered_sell_signal']]
            if not filtered_sells.empty:
                fig.add_trace(
                    go.Scatter(
                        x=filtered_sells.index,
                        y=data.loc[filtered_sells.index, 'high'] * 1.002,  # Above raw signals
                        mode='markers',
                        marker=dict(symbol='triangle-down', size=14, color='red', line=dict(width=2, color='black')),
                        name='Filtered Sell Signals'
                    )
                )
                
        # Add exit points for each entry signal
        for pair in entry_exit_pairs:
            # Define color map for exit reasons
            color_map = {
                'Atr Stop': 'red',
                'Momentum Exit': 'orange',
                'Profit Target': 'green',
                'Time Exit': 'purple',
                'End Of Day': 'black'
            }
            
            if pair['exit_time'] is not None and pair['exit_price'] is not None:
                # Get color based on exit reason
                marker_color = color_map.get(pair['exit_reason'], 'blue')
                
                # Add exit point marker
                fig.add_trace(
                    go.Scatter(
                        x=[pair['exit_time']],
                        y=[pair['exit_price']],
                        mode='markers',
                        marker=dict(
                            symbol='x', 
                            size=12, 
                            color=marker_color, 
                            line=dict(width=2, color='black')
                        ),
                        name=f"Exit {pair['position_type'].capitalize()} ({pair['exit_reason']})"
                    )
                )
                
                # Add line connecting entry to exit
                fig.add_trace(
                    go.Scatter(
                        x=[pair['entry_time'], pair['exit_time']],
                        y=[pair['entry_price'], pair['exit_price']],
                        mode='lines',
                        line=dict(color=marker_color, width=1, dash='dot'),
                        showlegend=False
                    )
                )
                
                # Add profit/loss annotation
                fig.add_annotation(
                    x=pair['exit_time'],
                    y=pair['exit_price'],
                    text=f"{pair['profit_pct']:.1f}%",
                    showarrow=True,
                    arrowhead=1,
                    ax=0,
                    ay=-40,
                    bgcolor=("green" if pair['profit_pct'] > 0 else "red"),
                    font=dict(color="white", size=10)
                )
        
        # Use a clean white theme with gridlines
        fig.update_layout(
            title='Price Chart with Trading Signals',
            xaxis_title='Time',
            yaxis_title='Price',
            template='plotly_white',
            height=600,
            xaxis_rangeslider_visible=False
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Display the entry/exit pairs in a table
        if entry_exit_pairs:
            st.subheader("Entry/Exit Pairs")
            
            # Create chronological list of all signals
            all_signals = []
            
            # Initialize pairs_data before using it
            pairs_data = []
            
            # Process each pair to extract both entry and exit signals
            for pair in entry_exit_pairs:
                try:
                    # Format timestamps
                    if hasattr(pair['entry_time'], 'tzinfo'):
                        entry_time = pair['entry_time'].strftime('%Y-%m-%d %H:%M:%S')
                    else:
                        entry_time = str(pair['entry_time'])
                        
                    if hasattr(pair['exit_time'], 'tzinfo'):
                        exit_time = pair['exit_time'].strftime('%Y-%m-%d %H:%M:%S') if pair['exit_time'] is not None else "N/A"
                    else:
                        exit_time = str(pair['exit_time']) if pair['exit_time'] is not None else "N/A"
                    
                    # Format prices
                    entry_price = f"${pair['entry_price']:.2f}" if pair['entry_price'] is not None else "N/A"
                    exit_price = f"${pair['exit_price']:.2f}" if pair['exit_price'] is not None else "N/A"
                    
                    # Calculate duration
                    duration_str = "N/A"
                    if pair['entry_time'] is not None and pair['exit_time'] is not None:
                        try:
                            duration = (pair['exit_time'] - pair['entry_time']).total_seconds() / 60
                            duration_str = f"{duration:.1f} min"
                        except Exception as e:
                            print(f"Error calculating duration: {str(e)}")
                    
                    # Add pair data with proper error handling for missing keys
                    pairs_data.append({
                        "Entry Type": pair.get('entry_type', 'Unknown'),
                        "Entry Time": entry_time,
                        "Entry Price": entry_price,
                        "Exit Time": exit_time,
                        "Exit Price": exit_price,
                        "Duration": duration_str,
                        "Exit Reason": pair.get('exit_reason', 'Unknown'),
                        "P&L": f"{pair.get('profit_pct', 0.0):.2f}%"
                    })
                    
                    # Add entry signal to chronological list
                    all_signals.append({
                        'time': pair['entry_time'],  # Original timestamp for sorting
                        'time_display': entry_time,
                        'type': f"ENTRY {pair['entry_type']}",
                        'price': entry_price,
                        'details': f"New {pair['entry_type']} position",
                        'id': id(pair)  # Use object ID to track related signals
                    })
                    
                    # Add exit signal to chronological list if it exists
                    if pair['exit_time'] is not None:
                        all_signals.append({
                            'time': pair['exit_time'],
                            'time_display': exit_time,
                            'type': f"EXIT {pair['entry_type']}",
                            'price': exit_price,
                            'details': f"Exit reason: {pair.get('exit_reason', 'Unknown')} (P&L: {pair.get('profit_pct', 0.0):.2f}%)",
                            'id': id(pair)
                        })
                except Exception as e:
                    print(f"Error processing pair: {str(e)}")
                    continue
            
            # Sort all signals chronologically
            all_signals.sort(key=lambda x: x['time'])
            
            # Create dataframe for display
            chrono_signals_df = pd.DataFrame([
                {
                    'Time': signal['time_display'],
                    'Signal': signal['type'],
                    'Price': signal['price'],
                    'Details': signal['details']
                }
                for signal in all_signals
            ])
            
            # Apply styling
            def color_signal_type(val):
                if "ENTRY BUY" in val:
                    return "background-color: #d4f7d4; color: #006400"
                elif "ENTRY SELL" in val:
                    return "background-color: #f7d4d4; color: #8b0000"
                elif "EXIT" in val:
                    return "background-color: #e6e6fa; color: #483d8b"
                return ""
            
            # Display chronological signals table
            st.dataframe(
                chrono_signals_df.style.applymap(color_signal_type, subset=['Signal']),
                use_container_width=True
            )
            
            # Original display of pairs data as reference (not chronological)
            with st.expander("View Original Entry/Exit Pairs"):
                original_pairs_data = []
                for pair in entry_exit_pairs:
                    try:
                        # Format timestamps
                        if hasattr(pair['entry_time'], 'tzinfo'):
                            entry_time = pair['entry_time'].strftime('%Y-%m-%d %H:%M:%S')
                        else:
                            entry_time = str(pair['entry_time'])
                            
                        if hasattr(pair['exit_time'], 'tzinfo'):
                            exit_time = pair['exit_time'].strftime('%Y-%m-%d %H:%M:%S') if pair['exit_time'] is not None else "N/A"
                        else:
                            exit_time = str(pair['exit_time']) if pair['exit_time'] is not None else "N/A"
                        
                        # Format prices
                        entry_price = f"${pair['entry_price']:.2f}" if pair['entry_price'] is not None else "N/A"
                        exit_price = f"${pair['exit_price']:.2f}" if pair['exit_price'] is not None else "N/A"
                        
                        # Calculate duration
                        duration_str = "N/A"
                        if pair['entry_time'] is not None and pair['exit_time'] is not None:
                            try:
                                duration = (pair['exit_time'] - pair['entry_time']).total_seconds() / 60
                                duration_str = f"{duration:.1f} min"
                            except Exception as e:
                                print(f"Error calculating duration in expander: {str(e)}")
                        
                        original_pairs_data.append({
                            "Entry Type": pair.get('entry_type', 'Unknown'),
                            "Entry Time": entry_time,
                            "Entry Price": entry_price,
                            "Exit Time": exit_time,
                            "Exit Price": exit_price,
                            "Duration": duration_str,
                            "Exit Reason": pair.get('exit_reason', 'Unknown'),
                            "P&L": f"{pair.get('profit_pct', 0.0):.2f}%"
                        })
                    except Exception as e:
                        print(f"Error processing pair in expander: {str(e)}")
                        continue
                
                # Create DataFrame
                pairs_df = pd.DataFrame(original_pairs_data)
                
                # Apply styling
                def highlight_pl(val):
                    if "%" in str(val):
                        try:
                            val_float = float(val.replace("%", ""))
                            if val_float > 0:
                                return "background-color: #d4f7d4; color: #006400"
                            elif val_float < 0:
                                return "background-color: #f7d4d4; color: #8b0000"
                        except:
                            pass
                    return ""
                
                # Style the dataframe
                styled_df = pairs_df.style.applymap(highlight_pl, subset=["P&L"])
                
                # Show the table
                st.dataframe(styled_df, use_container_width=True)
        
        # Add exit signal information for the signals
        st.subheader("Exit Recommendations for Current Positions")
        
        # Create exit recommendations for both position types
        position_types = ['long', 'short']
        
        for position_type in position_types:
            # Create a sample position at current price
            current_price = data['close'].iloc[-1]
            entry_time_offset = 15  # minutes ago
            
            # Calculate entry time based on offset
            entry_time = pd.Timestamp.now(tz=pytz.timezone('US/Eastern')) - pd.Timedelta(minutes=entry_time_offset)
            
            position = {
                'type': position_type,
                'entry_price': current_price,
                'entry_time': entry_time
            }
            
            # Analyze exit strategy
            exit_analysis = analyze_exit_strategy(data, position)
            
            if exit_analysis['success']:
                action = exit_analysis['action']
                
                # Format action recommendation
                if action['close_percent'] == 0:
                    recommendation = "HOLD position"
                    color = "blue"
                elif action['close_percent'] == 100:
                    recommendation = "CLOSE 100% of position"
                    color = "red"
                else:
                    recommendation = f"CLOSE {action['close_percent']}% of position"
                    color = "orange"
                
                # Create expandable section for each position type
                with st.expander(f"{position_type.upper()} Position Exit Strategy", expanded=True):
                    # Display action card with appropriate color
                    st.markdown(
                        f"""
                        <div style="padding: 10px; border-radius: 5px; background-color: {color}; color: white;">
                            <h3 style="margin: 0;">{recommendation}</h3>
                            <p style="margin: 5px 0 0 0;">Reason: {action['reason'].replace('_', ' ').title()}</p>
                        </div>
                        """, 
                        unsafe_allow_html=True
                    )
                    
                    # Display metrics
                    col1, col2, col3 = st.columns(3)
                    
                    with col1:
                        st.metric(
                            "Current P&L", 
                            f"{exit_analysis['metrics']['pnl_percent']:.2f}%",
                            delta=None
                        )
                    
                    with col2:
                        st.metric(
                            "Position Age", 
                            f"{exit_analysis['metrics']['position_age_minutes']:.1f} min",
                            delta=None
                        )
                    
                    with col3:
                        st.metric(
                            "Exit Probability", 
                            f"{exit_analysis['metrics']['exit_probability']*100:.1f}%",
                            delta=None
                        )
                    
                    # Display ATR stop level
                    if exit_analysis['atr_stop'] is not None:
                        st.markdown(f"**ATR Stop Level**: ${exit_analysis['atr_stop']:.2f}")
        
        # Show ATR and Cumulative Movement chart if available
        if 'atr' in data.columns and 'required_move' in signal_data.columns:
            st.subheader("ATR Filter Metrics")
            fig_atr = go.Figure()
            
            # Add ATR trace
            fig_atr.add_trace(
                go.Scatter(
                    x=data.index,
                    y=data['atr'],
                    mode='lines',
                    name='ATR',
                    line=dict(color='blue', width=1)
                )
            )
            
            # Add required move threshold
            if 'required_move' in signal_data.columns:
                fig_atr.add_trace(
                    go.Scatter(
                        x=signal_data.index,
                        y=signal_data['required_move'],
                        mode='lines',
                        name='Required Move Threshold',
                        line=dict(color='purple', width=1, dash='dash')
                    )
                )
            
            # Add cumulative move if available
            if 'cumulative_move' in signal_data.columns:
                fig_atr.add_trace(
                    go.Scatter(
                        x=signal_data.index,
                        y=signal_data['cumulative_move'],
                        mode='lines',
                        name='Cumulative Price Movement',
                        line=dict(color='orange', width=2)
                    )
                )
                
            # Use a clean white theme with gridlines
            fig_atr.update_layout(
                title='ATR and Price Movement',
                xaxis_title='Time',
                yaxis_title='Value',
                template='plotly_white',
                height=300,
                xaxis_rangeslider_visible=False
            )
            
            st.plotly_chart(fig_atr, use_container_width=True)
            
            # Show ATR filter configuration
            st.subheader("ATR Filter Configuration")
            col1, col2, col3 = st.columns(3)
            
            # Try to get values from the signal data
            atr_period = signal_data.get('atr_period', 20)
            k_value = signal_data.get('k', 0.82)
            smoothing = signal_data.get('smoothing', 'ema')
            
            with col1:
                st.metric("ATR Period", atr_period)
            with col2:
                st.metric("Threshold Multiplier (k)", round(k_value, 2))
            with col3:
                st.metric("ATR Smoothing", smoothing)
    
        # Display signal statistics
        st.subheader("Signal Statistics")
        
        # Count signals
        buy_count = signal_data['buy_signal'].sum()
        sell_count = signal_data['sell_signal'].sum()
        filtered_buy_count = signal_data['filtered_buy_signal'].sum() if 'filtered_buy_signal' in signal_data.columns else 0
        filtered_sell_count = signal_data['filtered_sell_signal'].sum() if 'filtered_sell_signal' in signal_data.columns else 0
        
        # Display metrics
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Raw Buy Signals", buy_count)
        with col2:
            st.metric("Raw Sell Signals", sell_count)
        with col3:
            st.metric("Filtered Buy Signals", filtered_buy_count)
            if filtered_buy_count < buy_count:
                st.caption(f"Reduced by {buy_count - filtered_buy_count} signals")
        with col4:
            st.metric("Filtered Sell Signals", filtered_sell_count)
            if filtered_sell_count < sell_count:
                st.caption(f"Reduced by {sell_count - filtered_sell_count} signals")
            
    except Exception as e:
        st.error(f"Error rendering price chart with signals: {str(e)}")
        st.code(traceback.format_exc())

    # After creating figure, add new section for sequential entry/exit visualization
    st.subheader("Sequential Entry/Exit Flow")
    
    # Find all signal transitions in chronological order
    position_flow = []
    current_position = None
    
    for idx in signal_data.index:
        # Check for buy entry
        if 'filtered_buy_signal' in signal_data.columns and signal_data.loc[idx, 'filtered_buy_signal']:
            if current_position != 'long':
                position_flow.append({
                    'time': idx,
                    'action': 'ENTER LONG',
                    'price': data.loc[idx, 'close'] if idx in data.index else None,
                    'color': 'green'
                })
                current_position = 'long'
        
        # Check for sell entry
        elif 'filtered_sell_signal' in signal_data.columns and signal_data.loc[idx, 'filtered_sell_signal']:
            if current_position != 'short':
                position_flow.append({
                    'time': idx,
                    'action': 'ENTER SHORT',
                    'price': data.loc[idx, 'close'] if idx in data.index else None,
                    'color': 'red'
                })
                current_position = 'short'
        
        # Check for buy exit
        if 'exit_buy' in signal_data.columns and signal_data.loc[idx, 'exit_buy']:
            if current_position == 'long':
                position_flow.append({
                    'time': idx,
                    'action': 'EXIT LONG',
                    'price': data.loc[idx, 'close'] if idx in data.index else None,
                    'color': 'blue'
                })
                current_position = None
        
        # Check for sell exit
        if 'exit_sell' in signal_data.columns and signal_data.loc[idx, 'exit_sell']:
            if current_position == 'short':
                position_flow.append({
                    'time': idx,
                    'action': 'EXIT SHORT',
                    'price': data.loc[idx, 'close'] if idx in data.index else None,
                    'color': 'orange'
                })
                current_position = None
    
    if position_flow:
        # Create a DataFrame for display
        flow_df = pd.DataFrame([
            {
                'Time': format_timestamp_as_et(p['time']),
                'Action': p['action'],
                'Price': f"${p['price']:.2f}" if p['price'] is not None else "N/A"
            }
            for p in position_flow
        ])
        
        # Apply styling based on action type
        def color_action(val):
            if 'ENTER LONG' in val:
                return 'background-color: rgba(0, 255, 0, 0.2)'
            elif 'ENTER SHORT' in val:
                return 'background-color: rgba(255, 0, 0, 0.2)'
            elif 'EXIT LONG' in val:
                return 'background-color: rgba(0, 0, 255, 0.2)'
            elif 'EXIT SHORT' in val:
                return 'background-color: rgba(255, 165, 0, 0.2)'
            return ''
        
        st.dataframe(
            flow_df.style.applymap(color_action, subset=['Action']),
            use_container_width=True
        )
        
        # Create a timeline visualization
        st.subheader("Position Timeline")
        
        # Convert to list of dictionaries for plotting
        timeline_data = []
        
        for i, p in enumerate(position_flow):
            # Format time for display
            if hasattr(p['time'], 'strftime'):
                time_str = p['time'].strftime('%H:%M:%S')
            else:
                time_str = str(p['time'])
                
            # Create dictionary for this event
            timeline_data.append({
                'Time': time_str,
                'Action': p['action'],
                'y': 1,  # Fixed y position
                'color': p['color']
            })
        
        # Create the timeline chart using plotly
        import plotly.graph_objects as go
        
        fig = go.Figure()
        
        # Add markers for each event
        fig.add_trace(
            go.Scatter(
                x=[p['Time'] for p in timeline_data],
                y=[p['y'] for p in timeline_data],
                mode='markers+text',
                marker=dict(
                    size=12,
                    color=[p['color'] for p in timeline_data],
                    symbol='circle'
                ),
                text=[p['Action'] for p in timeline_data],
                textposition='top center',
                name='Position Events'
            )
        )
        
        # Add connecting lines
        fig.add_trace(
            go.Scatter(
                x=[p['Time'] for p in timeline_data],
                y=[p['y'] for p in timeline_data],
                mode='lines',
                line=dict(color='gray', width=1, dash='dash'),
                showlegend=False
            )
        )
        
        # Format the layout
        fig.update_layout(
            title='Sequential Position Management Timeline',
            xaxis_title='Time',
            yaxis_visible=False,
            height=250,
            margin=dict(l=20, r=20, t=40, b=20),
            template='plotly_white'
        )
        
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("No position flow data available for timeline visualization")

def render_orb_signals(data, signals, symbol):
    """
    Render Opening Range Breakout signals visualization
    
    Args:
        data (pd.DataFrame): Price data
        signals (pd.DataFrame): Signals data
        symbol (str): Trading symbol
    """
    st.subheader(f"Opening Range Breakout Analysis: {symbol}")
    
    # Debug check for signals
    st.write("Checking ORB signal data structure:")
    
    if 'orb_signal' not in signals.columns:
        st.warning("No 'orb_signal' column found in signals DataFrame")
        return
    
    orb_signal_count = signals['orb_signal'].sum() if 'orb_signal' in signals.columns else 0
    st.write(f"Found {orb_signal_count} ORB signals in data")
    
    # Check if we have any ORB signals
    if orb_signal_count == 0:
        st.warning("No Opening Range Breakout signals detected in this data.")
        return
    
    # Filter to get only the rows with ORB signals
    orb_data = signals[signals['orb_signal'] == True]
    
    # Try to calculate ORB levels directly to make sure we can find them
    from app.indicators import calculate_opening_range
    
    # Ensure we have data in Eastern time
    eastern = pytz.timezone('US/Eastern')
    chart_data = data.copy()
    if chart_data.index.tzinfo is not None:
        chart_data.index = chart_data.index.tz_convert(eastern)
    
    # Calculate opening range
    orb_high, orb_low = calculate_opening_range(chart_data, minutes=5)
    
    # Create a simplified ORB chart first to verify it works
    fig = go.Figure()
    
    # Add candlestick chart
    fig.add_trace(go.Candlestick(
        x=chart_data.index,
        open=chart_data['open'],
        high=chart_data['high'],
        low=chart_data['low'],
        close=chart_data['close'],
        name='Price'
    ))
    
    # Add ORB levels if available
    if orb_high is not None:
        fig.add_shape(
            type="line",
            x0=chart_data.index[0],
            y0=orb_high,
            x1=chart_data.index[-1],
            y1=orb_high,
            line=dict(color="green", width=2, dash="dash"),
            name="ORB High"
        )
        
    if orb_low is not None:
        fig.add_shape(
            type="line",
            x0=chart_data.index[0],
            y0=orb_low,
            x1=chart_data.index[-1],
            y1=orb_low,
            line=dict(color="red", width=2, dash="dash"),
            name="ORB Low"
        )
    
    # Set chart title and labels
    fig.update_layout(
        title=f"Opening Range Breakout: {symbol}",
        xaxis_title="Time",
        yaxis_title="Price ($)",
        xaxis_rangeslider_visible=False,
        height=500
    )
    
    st.plotly_chart(fig, use_container_width=True)

def render_advanced_signals(tf_data_dict, view_mode="primary", symbol=None):
    """
    Render advanced signal analysis with multi-timeframe data
    
    Args:
        tf_data_dict (dict): Dictionary containing multi-timeframe data
        view_mode (str): View mode, either "primary" or "all"
        symbol (str): Trading symbol being analyzed
    """
    if not tf_data_dict or not isinstance(tf_data_dict, dict):
        st.warning("No multi-timeframe data available")
        return
        
    st.header("Advanced Signal Analysis")
    
    if symbol:
        st.subheader(f"Symbol: {symbol}")
    
    # Display the weighted signals section if available
    if 'weighted_signals' in tf_data_dict:
        weighted_signals = tf_data_dict['weighted_signals']
        
        # Create a table of timeframe signals
        st.subheader("Multi-Timeframe Analysis")
        
        tf_data_rows = []
        for tf_name, tf_data in weighted_signals.items():
            signals_data = tf_data['signals']
            weight = tf_data['weight']
            
            # Extract signal direction
            signal_direction = "Neutral"
            buy_signal = signals_data.get('buy_signal', False)
            sell_signal = signals_data.get('sell_signal', False)
            
            # Make sure we're evaluating the signals safely
            if isinstance(buy_signal, bool) and buy_signal:
                signal_direction = "Buy"
            elif isinstance(sell_signal, bool) and sell_signal:
                signal_direction = "Sell"
            # Handle DataFrame/Series cases explicitly
            elif not isinstance(buy_signal, bool) and not isinstance(sell_signal, bool):
                # Convert to bool if it's a DataFrame/Series value
                if hasattr(buy_signal, 'item') and buy_signal:
                    signal_direction = "Buy"
                elif hasattr(sell_signal, 'item') and sell_signal:
                    signal_direction = "Sell"
            
            # Extract score (use appropriate field or fallback to default)
            score = signals_data.get('buy_score', 0) if signal_direction == "Buy" else signals_data.get('sell_score', 0) if signal_direction == "Sell" else 0
            
            tf_data_rows.append({
                "Timeframe": tf_name,
                "Signal": signal_direction,
                "Score": f"{int(score * 100)}%" if signal_direction != "Neutral" else "-",
                "Weight": f"{weight:.1f}"
            })
        
        # Ensure we have data before creating a DataFrame
        if len(tf_data_rows) > 0:
            tf_df = pd.DataFrame(tf_data_rows)
            
            # Add styling to the dataframe
            def highlight_signal(val):
                color = 'white'
                if val == 'Buy':
                    color = '#d4f7d4'  # Light green
                elif val == 'Sell':
                    color = '#f7d4d4'  # Light red
                return f'background-color: {color}'
            
            st.dataframe(
                tf_df.style.applymap(highlight_signal, subset=['Signal']),
                use_container_width=True
            )
    
    # If there's a final signal, display it prominently
    if 'final_signal' in tf_data_dict:
        final_signal = tf_data_dict['final_signal']
        
        col1, col2 = st.columns(2)
        
        with col1:
            signal_type = "BUY" if final_signal.get('buy_signal', False) else "SELL" if final_signal.get('sell_signal', False) else "NEUTRAL"
            signal_strength = final_signal.get('signal_strength', 1)
            
            # Convert signal strength to text
            strength_map = {1: "WEAK", 2: "MODERATE", 3: "STRONG", 4: "VERY STRONG"}
            strength_text = strength_map.get(signal_strength, "Unknown")
            
            # Display signal with appropriate styling
            if signal_type == "BUY":
                st.markdown(f"""
                <div style="background-color: #d4f7d4; padding: 10px; border-radius: 5px; border: 1px solid #28a745;">
                    <h2 style="color: #28a745; margin: 0;">BUY SIGNAL ({strength_text})</h2>
                </div>
                """, unsafe_allow_html=True)
            elif signal_type == "SELL":
                st.markdown(f"""
                <div style="background-color: #f7d4d4; padding: 10px; border-radius: 5px; border: 1px solid #dc3545;">
                    <h2 style="color: #dc3545; margin: 0;">SELL SIGNAL ({strength_text})</h2>
                </div>
                """, unsafe_allow_html=True)
            else:
                st.markdown(f"""
                <div style="background-color: #e9ecef; padding: 10px; border-radius: 5px; border: 1px solid #6c757d;">
                    <h2 style="color: #6c757d; margin: 0;">NEUTRAL</h2>
                </div>
                """, unsafe_allow_html=True)
        
        with col2:
            # Display confidence score if available
            confidence = final_signal.get('confidence', None)
            if confidence is not None:
                st.metric("Signal Confidence", f"{int(confidence * 100)}%")
                
            # Display other metrics if available
            score = final_signal.get('buy_score', 0) if signal_type == "BUY" else final_signal.get('sell_score', 0) if signal_type == "SELL" else 0
            if score:
                st.metric("Signal Score", f"{int(score * 100)}%") 

def render_exit_strategy_analysis(data, position=None):
    """
    Render exit strategy analysis for an open position
    
    Args:
        data (pd.DataFrame): OHLCV price data
        position (dict, optional): Current position information. If None, allows creating a position.
    """
    from app.signals.generator import analyze_exit_strategy
    import streamlit as st
    
    st.subheader("Exit Strategy Analysis")
    
    # If no position is provided, allow creating one
    if position is None:
        st.write("No active position. Enter position details:")
        
        col1, col2, col3 = st.columns(3)
        with col1:
            position_type = st.radio("Position Type", ['long', 'short'])
        with col2:
            entry_price = st.number_input("Entry Price", min_value=0.01, value=data['close'].iloc[-1], step=0.01)
        with col3:
            entry_time_offset = st.number_input("Position Age (minutes)", min_value=1, value=15, step=1)
            
        # Calculate entry time based on offset
        entry_time = pd.Timestamp.now(tz=pytz.timezone('US/Eastern')) - pd.Timedelta(minutes=entry_time_offset)
        
        position = {
            'type': position_type,
            'entry_price': entry_price,
            'entry_time': entry_time
        }
    
    # Analyze exit strategy
    exit_analysis = analyze_exit_strategy(data, position)
    
    if not exit_analysis['success']:
        st.error(f"Error analyzing exit strategy: {exit_analysis.get('error', 'Unknown error')}")
        return
    
    # Display action recommendation
    action = exit_analysis['action']
    
    # Create exit action card
    st.markdown("### Exit Action")
    
    # Format action recommendation
    if action['close_percent'] == 0:
        recommendation = "HOLD position"
        color = "blue"
    elif action['close_percent'] == 100:
        recommendation = "CLOSE 100% of position"
        color = "red"
    else:
        recommendation = f"CLOSE {action['close_percent']}% of position"
        color = "orange"
    
    # Display action card with appropriate color
    st.markdown(
        f"""
        <div style="padding: 10px; border-radius: 5px; background-color: {color}; color: white;">
            <h3 style="margin: 0;">{recommendation}</h3>
            <p style="margin: 5px 0 0 0;">Reason: {action['reason'].replace('_', ' ').title()}</p>
        </div>
        """, 
        unsafe_allow_html=True
    )
    
    # Display metrics
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric(
            "Current P&L", 
            f"{exit_analysis['metrics']['pnl_percent']:.2f}%",
            delta=None
        )
    
    with col2:
        st.metric(
            "Position Age", 
            f"{exit_analysis['metrics']['position_age_minutes']:.1f} min",
            delta=None
        )
    
    with col3:
        st.metric(
            "Time-based Exit Probability", 
            f"{exit_analysis['metrics']['exit_probability']*100:.1f}%",
            delta=None
        )
    
    # Display ATR stop level
    if exit_analysis['atr_stop'] is not None:
        st.markdown(f"**ATR Stop Level**: ${exit_analysis['atr_stop']:.2f}")
    
    # Show stop adjustment if recommended
    if action['adjust_stop']:
        st.markdown(
            f"""
            <div style="padding: 10px; border-radius: 5px; background-color: green; color: white;">
                <p style="margin: 0;">Adjust stop loss to: ${action['new_stop']:.2f}</p>
            </div>
            """, 
            unsafe_allow_html=True
        )
    
    # Add signals visualization if available
    if 'signals' in exit_analysis and not exit_analysis['signals'].empty:
        st.subheader("Exit Signals")
        
        # Get the signals dataframe
        signals_df = exit_analysis['signals']
        
        # Show recent signals
        signals_display = signals_df.tail(10).copy()
        
        # Format the DataFrame for display
        for col in signals_display.columns:
            if col == 'atr_stop':
                signals_display[col] = signals_display[col].apply(lambda x: f"${x:.2f}")
            elif signals_display[col].dtype == bool:
                signals_display[col] = signals_display[col].apply(lambda x: "✓" if x else "")
        
        st.dataframe(signals_display) 